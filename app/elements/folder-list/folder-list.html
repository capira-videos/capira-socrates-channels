<dom-module id="folder-list">
  <style>
    :host {
      display: block;
      padding-top: 18px !important;
    }

    [list] {
      @apply(--layout-vertical);
    }

    [list-header] {
      @apply(--layout-horizontal);
      @apply(--layout-center);
      height: 64px;
    }

    [list-title] {
      @apply(--paper-font-headline);
    }

    [item] {
      @apply(--layout-horizontal);
    }

    [item-title] {
      @apply(--paper-font-subhead);
      margin-top: 5px;
      max-width: 460px;
    }

    a {
      text-decoration: none;
      color: black;
    }

    img {
      border: none;
    }

    .crop {
      float: left;
      margin: .5em 10px .5em 0;
      overflow: hidden;
      /* this is important */
      border: 0px solid #ccc;
    }
    /* input values to crop the image */

    .crop img {
      margin: -11px -0px -18px 0px
    }

    [selected] {
      background-color: red;
    }

    .sorting .sortable * {
        pointer-events: none; /* a nice hack to avoid that dragEnter and dragLeave
        get called for every child of a draggable.
        See http://stackoverflow.com/questions/7110353/html5-dragleave-fired-when-hovering-a-child-element*/
    }
  </style>
  <template>
    <rename-dialog id="rename" on-renamed="_onRenamed"></rename-dialog>

    <paper-toast id="removed" duration="7000">
      <a role="button" tabindex="0" style="color: #eeff41;margin: 10px" onclick="console.log('UNDO')">Undo</a>
    </paper-toast>

    <div list hidden$="{{isHidden()}}">
      <div list-header>
        <span list-title>
          <span>{{listTitle}}</span>s</span>
        <div class="flex"></div>
        <paper-icon-button icon="add" on-click="_createItem" hidden$="{{!isAuthor}}"></paper-icon-button>
      </div>
      <div>
        <div hidden$="{{list.0}}" class="paper-font-caption">
          Empty. There are no
          <span>
            <span>{{listTitle}}</span>s</span>
          in this Folder yet. Press + to create one.
        </div>

        <sortable-list sortable=".sortable" animation="150"
        on-sort-update="_onSorted" on-sort-start="_onSortStart"
        on-sort-move="_onMoved" on-sort-end="_onSortEnd" group="all-sortables">
            <template is="dom-repeat" items="{{list}}" id="listElement">
              <div item on-click="toggleSelection" selected$="[[item.selected]]"
              class="sortable" type="{{listTitle}}" on-dragleave="_dragLeave">
                <a href="{{reference(item)}}">
                  <span class="crop">
                    <img src="{{thumbnail(item)}}" />
                  </span>
                </a>
                <span item-title>{{item.title}}</span>
                <div class="flex"></div>
                <div hidden$="{{!isAuthor}}">
                  <paper-icon-button icon="delete" on-click="removeItem"></paper-icon-button>
                  <paper-icon-button icon="editor:mode-edit" on-click="_rename"></paper-icon-button>
                  <!--TODO: visibility of item  <paper-icon-button icon="social:public" on-click="promptDelete"></paper-icon-button> -->
                </div>
              </div>
            </template>
        </sortable-list>

        <array-selector id="selector" items="{{list}}" selected="{{selected}}" multi toggle></array-selector>
      </div>



      <editor-service id="service" on-responded="_handleResponse"></editor-service>
  </template>
</dom-module>


<script>
  (function() {
    Polymer({
      is: 'folder-list',
      properties: {
        list: Array,
        highlightedFolder: {
            type: HTMLElement,
            notify: true,
            value: null
        }
      },

      removeItem: function(event) {
        var item = event.model.item;
        item.deleted = true;
        item.folderId = this.folderId;
        this.$.service.generateRequest(this.listTitle.toLowerCase(), item);

        this.deleteIndex = this.list.indexOf(item);
        this.splice('list', this.deleteIndex, 1);

        var toast = this.$.removed;
        toast.text = 'Removed one ' + this.listTitle + '.';
        toast.show();
      },

      thumbnail: function(item) {
        return 'http://img.youtube.com/vi/' + (item.thumbnail ? item.thumbnail : item.videoId) + '/default.jpg';
      },

      reference: function(item) {
        if (item.videoId) {
          return this.unitRef(item);
        } else {
          return this.folderRef(item);
        }
      },

      unitRef: function(unit) {
        return 'https://capira.de/editor/#/' + unit.id;
      },

      folderRef: function(item) {
        return item.id;
      },

      _rename: function(e) {
        var item = this.$.listElement.itemForElement(e.target);
        var dialog = this.$.rename;
        dialog.open(item);
      },

      _onRenamed: function(e) {
        var item = e.detail;
        var i = this.list.indexOf(item);
        this.set('list.' + i + '.title', item.title);

        this.$.service.generateRequest(this.listTitle.toLowerCase(), item);
      },

      _onSortStart: function() {
          this._addOrRemoveSortingClass('add');
      },

      _onSortEnd: function() {
          this._addOrRemoveSortingClass('remove');
      },

      _addOrRemoveSortingClass: function(addOrRemove) {
          var parent = Polymer.dom(this).parentNode;
          var folderLists = Polymer.dom(parent).querySelectorAll('folder-list');
          folderLists.forEach(function(folderList) {
              var sortableList = Polymer.dom(folderList.root).querySelector('sortable-list');
              Polymer.dom(sortableList).classList[addOrRemove]('sorting');
          });
      },

      _onSorted: function(event) {
          var oldIndex = event.detail.oldIndex-1; // -1 because in the dom is a
          var newIndex = event.detail.newIndex-1; // <style> node as first child
          var dataEntry = this.list[oldIndex];
          // update the position in the dataset
          // One might maybe expect that some special treatment would be needed
          // as the dom element is switched first and then the databound list
          // entries are also switched which would result in a double switching.
          // Mind thereby that the binding of a data entry stays to the same
          // dom element. However, there is only one items data entry and dom
          // element affected. By changing its position using splices, polymer
          // reorders the dom elements and puts the dom element in the right
          // position, where it actually already happened to be. Thus, using
          // splices, we are save. this.set() doesnt have this behaviour
          // and results in the expected buggy behaviour.
          this.splice('list', oldIndex, 1); // remove at old position
          this.splice('list', newIndex, 0, dataEntry); // put at new position
    //      this.fire('sorted');
      },

      _onMoved: function(event) {
          var allowSorting;
          var dragged = event.detail.dragged;
          var related = event.detail.related;
          if (dragged.type==='Unit' && related.type==='Unit') {
              // a unit is moved along other units
              allowSorting = true;
          } else if (dragged.type==='Folder' && related.type==='Unit') {
              // a folder wants to move to the unit list
              allowSorting = false;
          } else if (dragged.type==='Unit' && related.type==='Folder') {
              // a unit can not be sorted along folders, however it can be
              // moved into a folder.
              allowSorting = false;
              this._highlightFolderForDropping(related);
          }
          event.returnValue = allowSorting;
      },

      _dragLeave: function(event) {
          // we can safely asume that dragLeave only gets called once when
          // leaving an element itself and not when leavin one of its children
          // as we are using pointer-events:none (see above)
          this._unHighlightFolderForDropping(event.target);
      },

      _highlightFolderForDropping: function(folderElement) {
          if (folderElement===this.highlightedFolder) {
              return;
          }
          console.log('highlighting',this.highlightedFolder, folderElement);
          folderElement.style.backgroundColor = 'lightblue';
          this.highlightedFolder = folderElement;
      },

      _unHighlightFolderForDropping: function(highlightedFolder) {
          highlightedFolder = highlightedFolder || this.highlightedFolder;
          if (highlightedFolder) {
              highlightedFolder.style.backgroundColor = 'white';
              console.log('unhighliting', this.highlightedFolder, highlightedFolder, this.highlightedFolder===highlightedFolder);
              if (this.highlightedFolder===highlightedFolder) {
                  this.highlightedFolder = null;
              }
          }
      },

      _createItem: function() {
        this.fire('create');
      },

      toggleSelection: function(e) {
        var item = this.$.listElement.itemForElement(e.target);
        item.selected = !item.selected;
        this.$.selector.select(item);
      },



    });
  })();
</script>
