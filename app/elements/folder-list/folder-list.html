<dom-module id="folder-list">
  <style>
    :host {
      display: block;
      padding-top: 18px !important;
    }

    [list] {
      @apply(--layout-vertical);
    }

    [list-header] {
      @apply(--layout-horizontal);
      @apply(--layout-center);
      height: 64px;
    }

    [list-title] {
      @apply(--paper-font-headline);
    }

    [item] {
      @apply(--layout-horizontal);
    }

    [item-title] {
      @apply(--paper-font-subhead);
      margin-top: 5px;
      max-width: 460px;
    }

    a {
      text-decoration: none;
      color: black;
    }

    img {
      border: none;
    }

    .crop {
      float: left;
      margin: .5em 10px .5em 0;
      overflow: hidden;
      /* this is important */
      border: 0px solid #ccc;
    }
    /* input values to crop the image */

    .crop img {
      margin: -11px -0px -18px 0px
    }

    [selected] {
      background-color: red;
    }

    .sorting .sortable * {
      pointer-events: none;
      /* a nice hack to avoid that dragEnter and dragLeave
    get called for every child of a draggable.
    See http://stackoverflow.com/questions/7110353/html5-dragleave-fired-when-hovering-a-child-element*/
    }
  </style>
  <template>
    <rename-dialog id="rename" on-renamed="_onRenamed"></rename-dialog>

    <paper-toast id="removed" duration="7000">
      <a role="button" tabindex="0" style="color: #eeff41;margin: 10px" onclick="console.log('UNDO')">Undo</a>
    </paper-toast>

    <div list hidden$="{{computeIsHidden(list,isAuthor)}}">
      <div list-header>
        <span list-title>
          <span>{{listTitle}}</span>s</span>
        <div class="flex"></div>
        <paper-icon-button icon="add" on-click="_createItem" hidden$="{{!isAuthor}}"></paper-icon-button>
      </div>
      <div>
        <div hidden$="{{list.0}}" class="paper-font-caption">
          Empty. There are no
          <span>
            <span>{{listTitle}}</span>s</span>
          in this Folder yet. Press + to create one.
        </div>

        <sortable-list id="sortable-list" sortable=".sortable" animation="150" on-sort-update="_onSorted" on-sort-start="_onSortStart" on-sort-move="_onMoved" on-sort-end="_onSortEnd" group="all-sortables">
          <template is="dom-repeat" items="{{list}}" id="listElement">
            <div item on-click="toggleSelection" selected$="[[item.selected]]" class="sortable" type="{{listTitle}}" on-dragleave="_dragLeave">
              <a href="{{reference(item)}}">
                <span class="crop">
                  <img src="{{thumbnail(item)}}" />
                </span>
              </a>
              <span item-title>{{item.title}}</span>
              <div class="flex"></div>
              <div hidden$="{{!isAuthor}}">
                <paper-icon-button icon="delete" on-click="removeItem"></paper-icon-button>
                <paper-icon-button icon="editor:mode-edit" on-click="_rename"></paper-icon-button>
                <!--TODO: visibility of item  <paper-icon-button icon="social:public" on-click="promptDelete"></paper-icon-button> -->
              </div>
            </div>
          </template>
        </sortable-list>

        <array-selector id="selector" items="{{list}}" selected="{{selected}}" multi toggle></array-selector>
      </div>



      <editor-service id="service" on-responded="_handleResponse"></editor-service>
  </template>
</dom-module>


<script>
  (function() {
    Polymer({
      is: 'folder-list',
      properties: {
        list: {
          type: Array,
          value: []
        },
        isAuthor: {
          type: Boolean,
          value: false
        },
        highlightedFolder: {
          type: HTMLElement,
          notify: true,
          value: null
        }
      },

      computeIsHidden: function(list, isAuthor) {
        return !(this.list.length > 0 || this.isAuthor);
      },

      removeItem: function(event) {
        var item = event.model.item;
        item.deleted = true;
        item.folderId = this.folderId;
        this.$.service.generateRequest(this.listTitle.toLowerCase(), item);

        this.deleteIndex = this.list.indexOf(item);
        this.splice('list', this.deleteIndex, 1);

        var toast = this.$.removed;
        toast.text = 'Removed one ' + this.listTitle + '.';
        toast.show();
      },

      thumbnail: function(item) {
        return 'http://img.youtube.com/vi/' + (item.thumbnail ? item.thumbnail : item.videoId) + '/default.jpg';
      },

      reference: function(item) {
        if (item.videoId) {
          return this.unitRef(item);
        } else {
          return this.folderRef(item);
        }
      },

      unitRef: function(unit) {
        return 'https://capira.de/'+(this.isAuthor?'editor':'player')+'/#/' + unit.id;
      },

      folderRef: function(item) {
        return item.id;
      },

      _rename: function(e) {
        var item = this.$.listElement.itemForElement(e.target);
        var dialog = this.$.rename;
        dialog.open(item);
      },

      _onRenamed: function(e) {
        var item = e.detail;
        var i = this.list.indexOf(item);
        this.set('list.' + i + '.title', item.title);

        this.$.service.generateRequest(this.listTitle.toLowerCase(), item);
      },

      _getFolderListElements: function() {
        var parent = Polymer.dom(this).parentNode;
        return Polymer.dom(parent).querySelectorAll('folder-list');
      },

      _getFolderListElement: function(type) {
        if (this.listTitle === type) {
          return this;
        } else {
          var folderLists = this._getFolderListElements();
          for (var i = 0; i < folderLists.length; ++i) {
            if (folderLists[i].listTitle === type) {
              return folderLists[i];
            }
          }
        }
      },

      _onDrag: function(event) {
        this._folderDragValues.mousePosition.x = event.clientX;
        this._folderDragValues.mousePosition.y = event.clientY;
      },

      _folderDragValues: {
        mousePosition: {
          x: 0,
          y: 0
        },
        currentlyHoveredFolder: null,
        enteredFrom: '' // bottom or top
      },

      _onSortStart: function(event) {
        this._getFolderListElements().forEach(function(folderList) {
          var sortableList = Polymer.dom(folderList.root).querySelector('sortable-list');
          Polymer.dom(sortableList).classList.add('sorting');
        });
        if (event.detail.item.type === 'Folder') {
          this.addEventListener('drag', this._onDrag);
        }
      },

      _onSortEnd: function(event) {
        var changePosition = function(oldIndex, newIndex) {
          var dataEntry = this.list[oldIndex];
          // update the position in the dataset
          // One might maybe expect that some special treatment would be needed
          // as the dom element is switched first and then the databound list
          // entries are also switched which would result in a double switching.
          // Mind thereby that the binding of a data entry stays to the same
          // dom element. However, there is only one items data entry and dom
          // element affected. By changing its position using splices, polymer
          // reorders the dom elements and puts the dom element in the right
          // position, where it actually already happened to be. Thus, using
          // splices, we are save. this.set() doesnt have this behaviour
          // and results in the expected buggy behaviour.
          this.splice('list', oldIndex, 1); // remove at old position
          this.splice('list', newIndex, 0, dataEntry); // put at new position
        }.bind(this)

        function computeIndex(domElement) {
          var index = 0;
          // Here we use native previousElementSibling by
          // purpose to also count shallow elements which were inserted
          // for shadydom polyfill.
          while (domElement = domElement.previousElementSibling) {
            index++;
          }
          return index;
        }

        // In shady dom, a style tag gets inserted in front of our sortable
        // items. In shadow dom its not. We have thus have to adapt our
        // retrieved indices. Native querySelector is used here to get
        // the current state of the actual dom. On shadow dom, the
        // indexOffset will correctly be 0.
        var indexOffset =
          computeIndex(this.$['sortable-list'].querySelector('.sortable'));
        var oldIndex = event.detail.oldIndex - indexOffset;
        var newIndex = event.detail.newIndex - indexOffset;

        // perform updates on dataset
        if (this.highlightedFolder) { // dropped into a folder
          var item = event.detail.item;
          var folderIndex = this._getFolderListElement('Folder')
            .$.listElement.indexForElement(this.highlightedFolder);
          var itemIndex = this._getFolderListElement(item.type)
            .$.listElement.indexForElement(item);
          console.log('Dropped ' + item.type + ' ' + itemIndex + ' into Folder ' + folderIndex);
        } else if (oldIndex !== newIndex) { // moved
          changePosition(oldIndex, newIndex);
          //      this.fire('sorted');
          console.log('Moved ' + event.detail.item.type + ' from position ' + oldIndex + ' to ' + newIndex);
        }

        // cleanup
        this._getFolderListElements().forEach(function(folderList) {
          var sortableList = Polymer.dom(folderList.root).querySelector('sortable-list');
          Polymer.dom(sortableList).classList.remove('sorting');
        });
        this._unHighlightFolderForDropping();
        if (event.detail.item.type === 'Folder') {
          this.removeEventListener('drag', this._onDrag);
          this._folderDragValues.currentlyHoveredFolder = null;
        }
      },

      _onMoved: function(event) {
        var allowSorting;
        var dragged = event.detail.dragged;
        var related = event.detail.related;
        if (dragged.type === 'Unit' && related.type === 'Unit') {
          // a unit is moved along other units
          allowSorting = true;
        } else if (dragged.type === 'Folder' && related.type === 'Unit') {
          // a folder wants to move to the unit list
          allowSorting = false;
        } else if (dragged.type === 'Unit' && related.type === 'Folder') {
          // a unit can not be sorted along folders, however it can be
          // moved into a folder.
          allowSorting = false;
          this._highlightFolderForDropping(related);
        } else if (dragged.type === 'Folder' && related.type === 'Folder') {
          // sort after moving with the mouse over the mid of the folder
          var relatedRect = event.detail.relatedRect;
          var mouseY = this._folderDragValues.mousePosition.y;
          var folderMidY = (relatedRect.top + relatedRect.bottom) / 2;
          if (related !== this._folderDragValues.currentlyHoveredFolder) {
            // freshly entered into new folder element
            allowSorting = false;
            this._folderDragValues.currentlyHoveredFolder = related;
            this._folderDragValues.enteredFrom = mouseY < folderMidY ?
              'top' : 'bottom';
            this._highlightFolderForDropping(related);
          } else {
            var overMid = (this._folderDragValues.enteredFrom === 'bottom' && mouseY < folderMidY) || (this._folderDragValues.enteredFrom === 'top' && mouseY > folderMidY);
            if (overMid) {
              allowSorting = true;
              this._unHighlightFolderForDropping(related);
            } else {
              allowSorting = false;
            }
          }
        }
        event.returnValue = allowSorting;
      },

      _dragLeave: function(event) {
        // we can safely asume that dragLeave only gets called once when
        // leaving an element itself and not when leavin one of its children
        // as we are using pointer-events:none (see above)
        if (event.target.type === "Folder") {
          this._unHighlightFolderForDropping(event.target);
          this._folderDragValues.currentlyHoveredFolder = null;
        }
      },

      // Some words about highlighting a folder:
      // Sortable.js uses HTML5 drag and drop which causes some problems.
      // Simple stuff like .folder:hover { background:green } doesn't work.
      // mouse events also did not trigger, so we had to use the dragLeave
      // event. This however gets not only called when leaving the drop target
      // (highlighted folder) but also when leaving any of it's children, also
      // when changing from one child to another. To reliably only trigger
      // dragLeave when the folder element is left, we set the children to
      // pointer-events:none; This ist done in onSortStart and onSortEnd on
      // both lists. To not trigger the highlighting over and over again (the
      // onMoved event gets called very often), we save a reference to the
      // highlightedFolder which is unset on unhighlighting. As the highlighting
      // for a unit does get triggered in the unit list, but the unhighlighting
      // in the dragLeave event of the folder list, the reference is kept
      // synchronous using databinding in folder-content.html
      _highlightFolderForDropping: function(folderElement) {
        if (folderElement === this.highlightedFolder) {
          return;
        }
        folderElement.style.backgroundColor = 'lightblue';
        this.highlightedFolder = folderElement;
      },

      _unHighlightFolderForDropping: function(highlightedFolder) {
        highlightedFolder = highlightedFolder || this.highlightedFolder;
        if (highlightedFolder) {
          highlightedFolder.style.backgroundColor = 'white';
          if (this.highlightedFolder === highlightedFolder) {
            this.highlightedFolder = null;
          }
        }
      },

      _createItem: function() {
        this.fire('create');
      },

      toggleSelection: function(e) {
        var item = this.$.listElement.itemForElement(e.target);
        item.selected = !item.selected;
        this.$.selector.select(item);
      }
    });
  })();
</script>
