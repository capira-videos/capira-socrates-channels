<dom-module id="folder-list">
<style>
:host {
    display: block;
    padding-top: 18px !important;
}

[list] {
    @apply(--layout-vertical);
}

[list-header] {
    @apply(--layout-horizontal);
    @apply(--layout-center);
    @apply(--material-container);
    height: 64px;
}

[list-title] {
    @apply(--paper-font-headline);
}

[isEmpty]{
    @apply(--paper-font-caption);
    @apply(--material-container);
}

.sortable-ghost {
    opacity: 0;
    position: relative;
}

</style>
<template>
    <rename-dialog id="rename" on-renamed="_onRenamed"></rename-dialog>
    <confirm-delete-dialog id="confirmDelete" on-delete-confirmed="removeItem"></confirm-delete-dialog>
    <div list hidden$="{{computeIsHidden(list,isAuthor)}}">
        <div list-header>
            <span list-title>
                <span>{{listTitle}}</span>s</span>
                <div class="flex"></div>
                <div>
                    <paper-icon-button icon="add" on-click="_createItem" hidden$="[[!isAuthor]]" id="create"></paper-icon-button>
                    <paper-tooltip for="create">Create a new <span>{{listTitle}}</span></paper-tooltip>
                </div>
            </div>
            <div hidden$="[[list.0]]" isEmpty>
                Empty. There are no
                <span>
                    <span>{{listTitle}}</span>s</span>
                    in this Folder yet. Press + to create one.
                </div>

                <sortable-droppable-list
                id="sortable-list" animation="150"
                disabled="[[!isAuthor]]" on-sort-change="_sortChanged"
                on-sort-drop="_droppedIntoFolder" type="[[listTitle]]"
                drop-targets='["Folder","Parent"]'>
                <template is="dom-if" if="[[_computeShowParentFolder(parentId,parentAuthor)]]">
                    <parent-folder type="Parent">
                    </parent-folder>
                </template>
                <template is="dom-repeat" items="[[list]]" id="listElement">
                    <list-item item="[[item]]" type="[[listTitle]]"
                    isAuthor="[[isAuthor]]" on-item-rename-requested="_onRenameRequested"
                    on-item-delete-requested="_onDeleteRequested" on-click="toggleSelection"
                    selected$="[[item.selected]]">
                    </list-item>
                </template>
            </sortable-droppable-list>
            <array-selector id="selector" items="[[list]]" selected="{{selected}}" multi toggle></array-selector>
            <channel-editor-service id="service"></channel-editor-service>
        </template>
    </dom-module>
    <script>
    (function() {
        Polymer({
            is: 'folder-list',
            properties: {
                list: {
                    type: Array,
                    value: [],
                    notify: true
                },
                isAuthor: {
                    type: Boolean,
                    value: false
                },
                parentId: {
                    type: Number
                },
                parentAuthor: {
                    type: Boolean
                }
            },

            computeIsHidden: function(list, isAuthor) {
                return !(list.length > 0 || isAuthor);
            },

            _computeShowParentFolder: function(parentId, parentAuthor) {
                return parentId && parentAuthor;
            },

            _saveItem: function(item) {
                return app.editorService.generateRequest(this.listTitle.toLowerCase(), item);
            },

            _onDeleteRequested: function(event) {
                this.$.confirmDelete.open(event.detail.item);
            },

            removeItem: function(event) {
                var item = event.detail;
                item.deleted = true;
                item.folderId = this.folderId; // the folder id is only for
                // unit defined, at least it seems so
                this._saveItem(item);

                this.deleteIndex = this.list.indexOf(item);
                this.splice('list', this.deleteIndex, 1);
            },

            _onRenameRequested: function(event) {
                this.$.rename.open(event.detail.item);
            },

            _onRenamed: function(e) {
                var item = e.detail;
                var i = this.list.indexOf(item);
                this.set('list.' + i + '.title', item.title);

                this._saveItem(item).then(function(e){
                    console.log('saved',e);
                });
            },

            _sortChanged: function(event) {
                // update the position in the dataset
                // One might maybe expect that some special treatment would be needed
                // as the dom element is switched first and then the databound list
                // entries are also switched which would result in a double switching.
                // Mind thereby that the binding of a data entry stays to the same
                // dom element. However, there is only one items data entry and dom
                // element affected. By changing its position using splices, polymer
                // reorders the dom elements and puts the dom element in the right
                // position, where it actually already happened to be. Thus, using
                // splices, we are save. this.set() doesnt have this behaviour
                // and results in the expected buggy behaviour.
                // As folders and units can not be mixed, we simply assume here that
                // event.oldList === event.newList === sortable-droppable-list here
                var entry = this.splice('list', event.detail.oldIndex, 1)[0]; // remove
                this.splice('list', event.detail.newIndex, 0, entry); // put at new position
                this.fire('sorted'); // fire event to save to database
                console.log('sort', event.detail);
            },

            _droppedIntoFolder: function(event) {
                console.log('drop', event.detail);
                var oldIndex = event.detail.oldIndex;
                var item = this.list[oldIndex];
                var folderEl = event.detail.dropTarget;
                if (folderEl.type==="Parent") {
                    if (!this.parentAuthor) {
                        return;
                    }
                    item.parent = folderEl.parentId;
                } else {
                    var folderList = event.detail.dropList;
                    while (folderList.tagName.toLowerCase()!=='folder-list') {
                        folderList = folderList.parentNode;
                    }
                    var folder = folderList.$.listElement.itemForElement(folderEl);
                    item.parent = folder.id;
                }
                this._saveItem(item); // save to database
                this.splice('list', oldIndex, 1); // remove from UI
            },

            _createItem: function() {
                this.fire('create');
            },

            toggleSelection: function(e) {
                var item = this.$.listElement.itemForElement(e.target);
                item.selected = !item.selected;
                this.$.selector.select(item);
            }
        });
    })();
    </script>
